# -*- coding: utf-8 -*-
"""sunhacks_findmymovie.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-ymBCudK7jXX5-FUZXcuekWgkEjloutg
"""

# !pip install pymongo
# !pip install flask

import os

from PIL import Image
import io
import torch
import torch.nn as nn
import torch.nn.functional as F
from torchvision import transforms
from torch.utils.data import Dataset, DataLoader
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
import base64

import pymongo
from pymongo import MongoClient
import matplotlib.pyplot as plt


device = torch.device("cuda" if torch.cuda.is_available() else "cpu")


class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        self.conv1 = nn.Conv2d(in_channels=3, out_channels=32, kernel_size=3, padding=1)
        self.pool = nn.MaxPool2d(kernel_size=2, stride=2)
        self.conv2 = nn.Conv2d(in_channels=32, out_channels=64, kernel_size=3, padding=1)
        self.conv3 = nn.Conv2d(in_channels=64, out_channels=128, kernel_size=3, padding=1)

        self.fc1 = nn.Linear(128 * 45 * 80, 128)

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = self.pool(F.relu(self.conv3(x)))
        x = x.view(-1, 128 * 45 * 80)  # Flatten
        x = F.relu(self.fc1(x))
        return x  # Return features


class MongoDBMovieDataset(Dataset):
    def __init__(self, collection, transform=None):
        self.collection = collection
        self.transform = transform
        self.image_data = list(self.collection.find())

    def __len__(self):
        return len(self.image_data)

    def __getitem__(self, idx):
        # Get the image document
        image_doc = self.image_data[idx]
        image_bytes = image_doc['image_data']  # Adjust the key based on your document structure
        folder_name = image_doc['movie_name']  # Assuming you have a field indicating the movie folder

        # Convert bytes to an image
        image = Image.open(io.BytesIO(image_bytes)).convert("RGB")

        if self.transform:
            image = self.transform(image)

        return image, folder_name  # Return both the image and the folder name


# Function to connect to MongoDB and load dataset
def load_data_from_mongodb(connection_string, database_name, collection_name):
    client = MongoClient(connection_string)
    db = client[database_name]
    collection = db[collection_name]
    dataset = MongoDBMovieDataset(collection, transform=transforms.Compose([transforms.Resize((360, 640)),transforms.ToTensor(),transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),]))
    dataloader = DataLoader(dataset, batch_size=64, shuffle=False)
    return dataloader

# Function to extract features from the model
def extract_features(model, dataloader):
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model.to(device)
    model.eval()  # Set the model to evaluation mode

    all_features = []
    movie_labels = []

    with torch.no_grad():
        for images, labels in dataloader:
            images = images.to(device)
            features = model(images)  # Extract features
            all_features.append(features.cpu())  # Collect features on CPU
            movie_labels.extend(labels)  # Collect movie folder labels

    return torch.cat(all_features, dim=0), movie_labels  # Return all features and labels


# Function to handle image upload and prediction
def handle_image_upload(image_path, model):
    # Load image
    image = Image.open(image_path)
    image = transforms.Resize((360, 640))(image)
    image = transforms.ToTensor()(image)
    image = transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))(image)

    model.eval()
    with torch.no_grad():
        output = model(image)
        _, predicted = torch.max(output, 1)
        return predicted.item()  # Return the predicted class

def find_similar_images(query_image, model, features, movie_labels, top_k=1):
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model.to(device)
    model.eval()
    transform = transforms.Compose([transforms.Resize((360, 640)),transforms.ToTensor(),transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),])
    # Apply transformations to the query image
    query_image = transform(query_image).unsqueeze(0).to(device)

    with torch.no_grad():
        query_features = model(query_image).cpu()  # Extract features of the query image

    # Calculate cosine similarity between the query image's features and all other features
    similarities = cosine_similarity(query_features, features)

    # Find the indices of the top-k most similar images
    top_k_indices = np.argsort(similarities[0])[::-1][:top_k]

    # Retrieve the corresponding movie labels for the top-k similar images
    similar_movie_labels = [movie_labels[idx] for idx in top_k_indices]

    return similar_movie_labels

def load_and_compress_image(image_path, quality=10):
    image = Image.open(image_path).convert("RGB")
    buffer = io.BytesIO()
    image.save(buffer, format="JPEG", quality=quality)
    buffer.seek(0)
    return Image.open(buffer)


# Main function to run the model
def findmymovie(connection_string, database_name, collection_name, image_path):
    # Load dataset from MongoDB
    dataloader = load_data_from_mongodb(connection_string, database_name, collection_name)

    # Initialize and load the model
    model = SimpleCNN().to(device)

    # Extract features from the dataset
    features, movie_labels = extract_features(model, dataloader)
    print("Feature extraction complete.")
    print(f"Extracted features shape: {features.shape}")

    # Handle image upload and predict
    # query_image = Image.open(image_path).convert("RGB")
    query_image = load_and_compress_image(image_path, quality=10)
    plt.imshow(query_image)
    plt.axis('off')  # Hide axis
    plt.title('Image that you uploaded')
    plt.show()
    predicted_movie = find_similar_images(query_image, model, features, movie_labels, top_k=1)
    print(f'Predicted Label: {predicted_movie}')
    return predicted_movie


def final_code(path):
    CONNECTION_STRING = "mongodb+srv://sbuddha4:Q1w2e3r4t5y69*@movieframes.quhx9.mongodb.net/"
    DATABASE_NAME = "sunhacks2024"
    COLLECTION_NAME = "Movie_Frames"
    YOUR_IMAGE_PATH = path  # Specify the path to the image you want to predict

    return findmymovie(CONNECTION_STRING, DATABASE_NAME, COLLECTION_NAME, YOUR_IMAGE_PATH)
    
# # Example usage
# if __name__ == "__main__":
#     final_code()
    

